
\section{Rappel}
\subsection{Paramètres formels/paramètres effectifs}

\begin{frame}
  \frametitle{Fonction fact}%\chrono}

  \begin{itemize}[<+-|alert@+>]
  \item Paramètres formels
  \item Paramètres effectifs
  \end{itemize}

  \begin{semiverbatim}
    def \textcolor{blue}{fact}({\color<1>{red} nb}):

    \hspace{1cm}if(nb == 0):

    \hspace{1cm}...


    def cnp(n, p):

    \hspace{1cm}num = \textcolor{blue}{fact}({\color<2>{red}n})

    \hspace{1cm}...

  
  \end{semiverbatim}
\end{frame}
\subsection{Portée de variable}
\begin{frame}[fragile]
  \frametitle{Variables globales/locales}%}
  
	\begin{remarques}
	\begin{itemize}[<+->]
		\item Les variables globales sont visibles dans les fonctions appelées mais on ne peut les réaffecter
		\item Le contenu d'une variable globale est modifiable si elle est mutable (modifiable).
		\item Les variables locales d'une fonction ne sont pas visibles dans les niveaux supérieurs
		\item Les fonctions peuvent modifier des variables globales (les types non modifiables)  avec l'instruction \emph{global} 
		\item La fonction \emph{globals()} retourne le dictionnaire des objets (variables) globaux. \\
		\item La fonction \emph{locals()} retourne la liste des objets de l'espace local en cours
   \end{itemize}
  \end{remarques}
	
\end{frame}
\begin{frame}[fragile]
  \frametitle{Variables globales/locales}%}
\small{
 \begin{exemple}[Modification d'une variable globale en local]
    \begin{semiverbatim}
		\textcolor[rgb]{0,0,1}{def} incremCompt():  \textcolor[rgb]{0,0.58,0}{ # fonction sans param. d'entrée}
    \only<1>{\textcolor[rgb]{0,0,1}{global} compteur  \textcolor[rgb]{0,0.58,0}{# définition var. globale}}
    compteur += 1
    print('Appelé', compteur, 'fois')

compteur = 0 \textcolor[rgb]{0,0.58,0}{# initialisation du compteur}
\only<1>{incremCompt() \textcolor[rgb]{0,0.58,0}{# => affiche: Appelé 1 fois} 
incremCompt() \textcolor[rgb]{0,0.58,0}{# => affiche: Appelé 2 fois}
incremCompt() \textcolor[rgb]{0,0.58,0}{# => affiche: Appelé 3 fois}}
\only<2-3>{incremCompt() \textcolor[rgb]{0,0.58,0}{# => affiche: Appelé 1 fois ? V/F?}  
incremCompt() \textcolor[rgb]{0,0.58,0}{# => affiche: Appelé 1 fois V/F?}
}
\only<3>{\color{red}{UnboundLocalError: local variable 'compteur' 
referenced before assignment}}
				
 \end{semiverbatim}




  \end{exemple}
	}
%}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Variables globales/locales}%}
\small{
 \begin{exemple}[Modification d'une variable globale en local]
    \begin{semiverbatim}
		\textcolor[rgb]{0,0,1}{def} maville(lm):
    ville = "Brest" \# variable locale
    print (ville, cp,lm)
    \onslide<2->{test()   
\textcolor[rgb]{0,0,1}{def} test():
    print('test',ville)
}    

\textcolor[rgb]{0,0.58,0}{\# cp=29200 variable globale vue par la fct}
cp = 29200 \textcolor[rgb]{0,0.58,0}{\# variable globale}
maville('France') \textcolor[rgb]{0,0.58,0}{\# => affiche 'Brest 29200 France'}
\onslide<3>{\# => affiche 'test, Brest'	V/F? }
			
 \end{semiverbatim}
  \end{exemple}
	}
%}
\end{frame}

\section{Récursivité}


\subsection{Définition}


\begin{frame}
  \frametitle{Définition}%}
\begin{defi}[Fonction récursive]
  Une fonction ou une méthode est dite récursive si elle se définit à partir
  d'elle même, c'est-à-dire si elle comporte \textbf{au moins} un appel à elle même dans son
  corps.
\end{defi}

\pause
\begin{alertblock}{Attention}
  Éviter les boucles infinies (appel systématique à la fonction).
\end{alertblock}
\pause
\begin{exemple}[Fonction infinie]
  \begin{semiverbatim}
    def sansFin(n):

    \hspace{1cm}return n+sansFin(n-1)

   
  \end{semiverbatim}
\end{exemple}
\end{frame}


\begin{frame}
  \frametitle{Exemple}%}

  Traduction immédiate des fonctions définies par récurrence.

  \begin{exemple}[Factorielle]
    $\left\{
      \begin{array}{l}
        \color<3>{red}0! = 1\\
        \color<4>{red}n! = n(n-1)!
      \end{array}
    \right.
    $\\
    
    \pause

    \begin{semiverbatim}
      def \textcolor{blue}{fact}(n):\pause

      \hspace{1cm}if n==0 : \only<5>{\textcolor[rgb]{0,0.58,0}{\# Condition d'arrêt}}

      \hspace{2cm}return 1\pause

      \hspace{1cm}else:

      \hspace{2cm}return n * \textcolor{blue}{fact}(n-1)

    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}
  \frametitle{Condition d'arrêt}%}

  \begin{defi}[Condition d'arrêt]
    Condition pour laquelle il n'y a pas d'appel récursif.
  \end{defi}
  \pause
  \begin{alertblock}{Important}
    Toute fonction récursive doit comporter au moins une condition
    d'arrêt. Sinon : boucle infinie.
  \end{alertblock}
  \pause
  \begin{remarque}
    Une fonction peut comporter plusieurs conditions d'arrêt.
  \end{remarque}
\end{frame}


\begin{frame}
  \frametitle{Condition d'arrêt}%}
  \begin{exemple}[Plusieurs conditions d'arrêt]
    \begin{semiverbatim}
      def fact(n):

      \hspace{1cm}{\color<2>{red}if (n==0):}
      
      \hspace{2cm}return 1

      \hspace{1cm}{\color<2>{red}elif (n==1):}

      \hspace{2cm}return 1

      \hspace{1cm}else :

      \hspace{2cm}return n * fact(n-1)

    \end{semiverbatim}
  \end{exemple}
\end{frame}


\subsection{Pile d'appel}

%\begin{frame}
  %\frametitle{Pile d'appel}
  %\begin{itemize}[<+->]
  %\item Zone de mémoire
  %\item Contient :
    %\begin{itemize}
    %\item<3-|alert@8-9> paramètres
    %\item<4-|alert@10> adresse de retour
    %\item<5-|alert@11> variables locales
		%\item<6-|alert@12> variables globales
    %\end{itemize}
  %\item<7-> Fonctionnement lors de l'appel d'une fonction
  %\end{itemize}
%
  %\uncover<8->{
  %\begin{tabular}{ll}
    %\begin{minipage}{0.8\linewidth}
    %\begin{semiverbatim}
      %def methode({\color<8>{red} a}, {\color<9>{red} b}):
%
      %\hspace{1cm}{\color<11>{red} i = 0}
			%\hspace{1cm} ...
			%
      %methode({\color<8>{red}2}, {\color<9>{red}1.5})
    %\end{semiverbatim}
  %\end{minipage}&
  %\begin{minipage}{0.15\linewidth}
  %\begin{tabular}{|r|}
    %\hline
    %\uncover<11>{i}\\
    %\hline
    %\uncover<10->{0x1E3C85}\\
    %\hline
    %\uncover<9->{1.5}\\
    %\hline
    %\uncover<8->{2}\\
    %\hline
  %\end{tabular}
  %\end{minipage}
%\end{tabular}
%}
%\end{frame}
%

\begin{frame}
  \frametitle{Pile et récursivité}%}

  \begin{itemize}
  \item Pile d'appel : notion fondamentale pour la récursivité.
  \item Principe : tous les appels sont empilés, traités, puis dépilés.
  \end{itemize}	
		
		~\\

  \begin{tabular}{ll}
    \begin{minipage}{0.6\linewidth}
    \begin{semiverbatim}
      def fact(n) :

      \hspace{1cm}if n==0:

      \hspace{2cm}return 1

      \hspace{1cm}else:

      \hspace{2cm}return n*fact(n-1)


    \textcolor[rgb]{1,0,0}{>>>res = fact(2)}
    \end{semiverbatim}
  \end{minipage}&
  \begin{minipage}{0.35\linewidth}
  \begin{tabular}{|ll|}
    \hline
    \uncover<5-6>{fact(0)}&\uncover<6>{=1}\\
    \hline
    \uncover<3-7>{fact(1)}&\uncover<4-7>{=\only<-6>{1*fact(0)}\only<7->{1}}\\
    \hline
    fact(2)&\uncover<2->{=\only<-7>{2*fact(1)}\only<8->{2}}\\
    \hline
  \end{tabular}
  \end{minipage}
\end{tabular}

\end{frame}

\subsection{Mécanisme des traitements}



\begin{frame}[fragile]
  \frametitle{Post et pré-traitement}%}
 
 \begin{exemple}[Puissance d'entier : x**n]

  \begin{semiverbatim}\scriptsize{
	\vspace{-0.8cm}
	def puissance(x,n):
	    if n == 0:
	        \only<2->{print("cas de base n :", n)}
	        return 1 \uncover<2->{\textcolor[rgb]{0,0.58,0}{\# cas de base}}
	    else:
	        \only<2,3,5>{print("prétraitement pour n :", n)} 
	        \only<1-3>{return}\only<4->{y =} x* puissance (x, n-1)
	        \only<4->{print("post-traitement n :", n)} 
	        \only<4->{return y}
	puissance(2,5)}
\textcolor[rgb]{0,0.58,0}{\# sortie}
\only<3,5>{\tiny{pretraitement de n :  5
pretraitement de n :  4
pretraitement de n :  3
pretraitement de n :  2
pretraitement de n :  1}}
\only<3-5>{\tiny{cas de base n : 0}}
\only<4-5>{\tiny{post-traitement de n: 1
post-traitement de n : 2
post-traitement de n : 3
post-traitement de n : 4
post-traitement de n : 5}}
  \end{semiverbatim}
	
\end{exemple}


\end{frame}
\subsection{Explosion combinatoire}

\begin{frame}
  \frametitle{Suite de Fibonacci}%}
  $\left\{
    \begin{array}{l}
      \color<2>{red}F_0 = 0\\
      \color<2>{red}F_1 = 1\\
      \color<3>{red}\forall n \geqslant 2, F_n = F_{n-1} + F_{n-2}
    \end{array}
  \right.
  $\\

  \only<2-3>{
    \begin{itemize}
    \item<2-> Deux conditions d'arrêt
    \item<3-> Une condition de récurrence
    \end{itemize}}
  
  \only<4->{
    \begin{semiverbatim}
      def \textcolor{blue}{fibo}(n):
      
      \hspace{1cm}if n==0:
      
      \hspace{2cm}return 0

      \hspace{1cm}elif n==1:

      \hspace{2cm}return 1

      \hspace{1cm}else

      \hspace{2cm}return \textcolor{blue}{fibo}(n-1) + \textcolor{blue}{fibo}(n-2)
    
    \end{semiverbatim}
  }
\end{frame}

\begin{frame}
  \frametitle{Explosion de la pile d'appels}%}
  Évolution de la pile lors du calcul de F(3) :\\
  \begin{tabular}{|ll|}
    \hline
    \uncover<7-8>{\color<7-8>{purple}f(0)} & \uncover<8>{= 0}\\
    \hline
    \uncover<5-8,10-11>{\color<4-6>{purple}\color<10-11>{blue}f(1)} & \uncover<6-8,11>{= 1}\\
    \hline
    \uncover<3-11>{\color<3-9>{blue}f(2)} & \uncover<4-11>{= \only<-8>{{\color<4-6>{purple}f(1)}+{\color<7-9>{purple}f(0)}}\only<9->{1}}\\
    \hline
    f(3) & \uncover<2->{= \only<2-11>{{\color<2-9>{blue}f(2)}+{\color<10-11>{blue}f(1)}} \only<12->{2}}\\
    \hline
  \end{tabular}\\
	\footnotesize{
  \begin{itemize}
  \item<13-> Traduction immédiate de la formule de récurrence
  \item[$\Rightarrow$]<14-> peu efficace dans ce cas
  \item<15-> Nombre d'appels à F en $\Theta(2^n)$
  \end{itemize}
	}
	\tiny{
	\uncover<16->{
	\begin{alertblock}{Important}
	 \begin{itemize}
		 \item <16-> Le nombre d'appels est limité par défaut, à 1000 appels. \\ $\Rightarrow$ \small{\emph{RuntimeError: maximum recursion depth exceeded ...}} 
		 \item <17> Exemple : Augmenter la taille à  1500: \texttt{sys.setrecursionlimit(1500)} 
	 \end{itemize}
		\end{alertblock}	}
}
  
\end{frame}


\subsection{Conception d'algorithme récursif}

\begin{frame}
  \frametitle{Conception d'algorithme récursif}%}

  \begin{itemize}[<+->]
  \item Découper l'algorithme en étapes
  \item Déterminer les règles de passage d'une étape à l'autre
  \item[$\Rightarrow$] l'étape $n$ dépend de l'étape $n-1$ (éventuellement $n-2$)
  \item Déterminer les conditions d'arrêt
  \end{itemize}

  \pause
  \begin{remarque}
    Tout algorithme récursif peut s'écrire de manière itérative, et
    réciproquement. 
  \end{remarque}
\end{frame}


\subsection{Exemples}

\begin{frame}
  \frametitle{Recherche par dichotomie}%}

  \begin{itemize}[<+->]
  \item Recherche d'un élément dans un tableau trié
  \item Principe :
    \begin{itemize}
    \item comparer l'élément recherché avec le milieu du tableau
    \item si $>$ : recherche dans le tableau $\Leftrightarrow$ recherche dans
      la partie droite
    \item si $<$ : recherche dans le tableau $\Leftrightarrow$ recherche dans
      la partie gauche
    \item si $=$ : élément trouvé (condition d'arrêt)
    \item autre condition d'arrêt : taille du tableau  $\leqslant 1$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recherche par dichotomie}%}
  \begin{semiverbatim}
    def rech(tab, val, deb, fin):

  \hspace{1cm}n = (deb + fin)//2 \pause

  \hspace{1cm}if tab[n] == val:

    \hspace{2cm}return True \pause

  \hspace{1cm}elif deb >= fin :

    \hspace{2cm}return False \pause

  \hspace{1cm}elif tab[n] > val:

    \hspace{2cm}return rech(tab, val, deb, n-1)

  \hspace{1cm}else:

    \hspace{2cm}return rech(tab, val, n+1, fin)

  \end{semiverbatim}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Tours de Hanoï}%}
  Principe :
  \begin{itemize}
  \item Disques empilés : tour
  \item Ne jamais empiler un disque sur un disque plus petit
  \item Déplacer un seul disque à la fois
  \end{itemize}
  \begin{center}
\tikzset{
    disc/.style={shade, shading=radial, rounded rectangle,minimum height=.3cm,
        inner color=#1!20, outer color=#1!60!gray},
    disc 1/.style={disc=yellow, minimum width=12mm},
    disc 2/.style={disc=orange, minimum width=16mm},
    disc 3/.style={disc=red, minimum width=20mm},
    disc 4/.style={disc=green, minimum width=24mm},
    disc 5/.style={disc=blue, minimum width=28mm},
    disc 6/.style={disc=purple, minimum width=32mm},
    disc 7/.style={disc=teal, minimum width=36mm},
}

% Define some colors, I don't like plain green and brown.
\definecolor{darkgreen}{rgb}{0.2,0.55,0}
\definecolor{darkbrown}{rgb}{0.375,0.25,0.125}

\begin{tikzpicture}
  \foreach \n/\x in {1/0cm,2/3.5cm,3/7cm} {
    \begin{scope}[xshift=\x]
      \fill[darkbrown] (-1.5cm, 0) rectangle (1.5cm,0.2cm)
      (-1mm,2mm) rectangle (1mm,3.2cm);
      \ifnum \n=1
      \foreach \y in {1,...,7} {
        \node[disc \y,yshift={32mm-\y*4mm}] {\scriptsize\y};
      }
      \fi
      % \expandafter\discs\csname pole \n\endcsname
    \end{scope}
  }
\end{tikzpicture}
   % \includegraphics[width=0.7\linewidth]{tours_hanoi}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Tours de Hanoï : résolution}%}
  \begin{itemize}
  \item Résolution par une fonction récursive
  \item Étapes de l'algorithme : hauteur de la tour
  \item Hauteur 0 : évident
  \item Récurrence :
    \begin{itemize}
    \item on suppose savoir déplacer une tour de hauteur $h-1$
    \item on veut déplacer une tour de hauteur $h$ de A vers B
    \item déplacer les $h-1$ premiers éléments de A vers C
    \item déplacer l'élément restant de A vers B
    \item déplacer les $h-1$ premiers éléments de C vers B
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tours de Hanoï : algorithme}%}

%\begin{algorithme}{Algorithme des tours de Hanoï}{alg:hanoi}
%  \proc \algverb{hanoi} (entier n, entier source, entier dest, entier tmp)\\
%  \vars \=\\
%  \> n : hauteur de la tour\\
%  \> source, dest, tmp\\
%  \debut \=\\
%  \> \si \= $n>0$ \alors\\
%  \> \> hanoi(n-1, source, tmp, dest)\\
%  \> \> déplacer(source, dest)\\
%  \> \> hanoi(n-1, tmp, dest, source)\\
%  \> \fin\\
%  \fin
%\end{algorithme}
  {\small 
\begin{procedure}[H]
  \caption{hanoi(entier n, entier source, entier dest, entier tmp)}
  \tcc{n~: hauteur de la tour\\ source, dest, tmp~: 
    position d'origine, finale et intermédiaire de la tour à déplacer}
  \If{$n>0$} { 
    \hanoi(n-1, source, tmp, dest) \;
    déplacer(source, dest) \;
    \hanoi(n-1, tmp, dest, source) \;
  }
\end{procedure}
% \begin{algorithmic}[1]
%     \Procedure{Hanoï}{entier n, entier source, entier dest, entier tmp}
%     \Var
%     \State n : hauteur de la tour
%     \State source, dest, tmp
%     \EndVar
%     \If{$n>0$}
%     \State hanoi(n-1, source, tmp, dest)
%     \State déplacer(source, dest)
%     \State hanoi(n-1, tmp, dest, source)
%     \EndIf
%     \EndProcedure
%   \end{algorithmic}
}
\end{frame}

\begin{frame}
  \frametitle{Étude de l'algorithme tours de Hanoï}%}
  $C(n)$ : nombre d'opération pour déplacer une tour de hauteur $n$\\
  \pause ~\\
    $\left\{
      \begin{array}{l}
        C(n+1) = 2C(n) + 1\\
        C(0) = 0
      \end{array}
    \right.
    $\\
    \pause ~\\
    Résolution : $C(n) = 2^n - 1$
    
    \vspace{2mm}\pause 
    Légende des tours de Hanoï : dans un temple Bouddhiste, des moines ont reçu
    pour mission de déplacer une tour de Hanoï de 64 disques. Lorsqu'ils
    l'auront déplacée, le monde tombera en poussière.\\
    \pause
    $2^{64}-1 = 18\, 446\, 744\, 073\, 709\, 551\, 615$

    Un déplacement par seconde $\leadsto$ 580 milliards d'années
\end{frame}


%\begin{frame}
  %\frametitle{Monnaie}
  %Problème : 
  %\begin{itemize}[<+->]
  %\item Combien de manières de rendre la monnaie sur une somme $s$
    %avec 1, 2 ou 5 \euro{} ?
  %\item Résolution : méthodes récursives.
  %\end{itemize}
%
  %\pause Algorithme :
  %\begin{itemize}[<+->]
  %\item Rendre la monnaie sur $s$ avec des pièces de 1 \euro{} : 1 seule possibilité
  %\item Rendre la monnaie sur $s$ avec 1 ou 2 \euro{} :
    %\begin{itemize}
    %\item Donner une pièce de 2\euro{} et rendre la monnaie sur $s-2$ avec 1 ou
      %2 \euro{}
    %\item Ou rendre la monnaie uniquement avec 1\euro{}
    %\end{itemize}
  %\item Rendre la monnaie sur $s$ avec 1, 2 ou 5 \euro{} : même principe
  %\end{itemize}
%\end{frame}
%
%\begin{frame}
  %\frametitle{Algorithme}
%%  \begin{algorithme}{Rendre la monnaie}{alg:monnaie}
%%    \proc \algverb{monnaie1} (somme s)\\
%%    \debut \=\\
%%    \> retourner 1\\
%%    \fin\\ \pause
%%    \proc \algverb{monnaie1-2} (somme s)\\
%%    \debut \=\\
%%    \> retourner monnaie1-2(s-2) + monnaie1(s)\\
%%    \fin\\ \pause
%%    \proc \algverb{monnaie1-2-5} (somme s)\\
%%    \debut \=\\
%%    \> retourner monnaie1-2-5(s-5) + monnaie1-2(s) + monnaie1(s)\\
%%    \fin
%%  \end{algorithme}
  %{\small 
%\begin{procedure}[H]
  %\caption{monnaie1(somme s)}
  %retourner 1\;
%\end{procedure}
%\begin{procedure}[H]
  %\caption{monnaie1-2(somme s)}
 %retourner \emph{monnaie1-2}(s-2) + \emph{monnaie1}(s)\;
%\end{procedure}
%\begin{procedure}[H]
  %\caption{monnaie1-2-5(somme s)}
 %retourner \emph{monnaie1-2-5}(s-5) + \emph{monnaie1-2}(s) + \emph{monnaie1}(s)\;
%\end{procedure}
%
%% \begin{algorithmic}[1]
%%     \Procedure{monnaie1}{somme s}
%%       \State retourner 1
%%     \EndProcedure
%%     \Procedure{monnaie1-2}{somme s}
%%       \State retourner monnaie1-2(s-2) + monnaie1(s)
%%     \EndProcedure
%%     \Procedure{monnaie1-2-5}{somme s}
%%       \State retourner monnaie1-2-5(s-5) + monnaie1-2(s) + monnaie1(s)
%%     \EndProcedure
%%   \end{algorithmic}
%}
%\end{frame}
%
%\begin{frame}
  %\frametitle{Algorithme : condition d'arrêt}
  %\begin{itemize}
  %\item Conditions d'arrêt de l'algorithme ?
  %\item \emph{monnaie1} non récursive : pas de condition d'arrêt
  %\item Pour \emph{monnaie1-2} : s'arrêter si $s<2$
  %\item Pour \emph{monnaie1-2-5} : s'arrêter si $s<5$
  %\end{itemize}
%\end{frame}
%
%\begin{frame}
  %\frametitle{Quicksort}%}
%\only<1-4>{
  %{\small 
%\begin{procedure}[H]
  %\caption{triSeg(tableau\_entier tab, entier debut, entier fin)}
  %\If{$debut<fin$} {\pause
      %choisir élément pivot $p$ entre debut et fin \;\pause
      %placer pivot en $i$, $\leqslant$ pivot avant, $\geqslant$ pivot après \;\pause
      %\triSeg(tab, deb, i-1) \;
      %\triSeg(tab, i+1, fin) \;
  %}
%\end{procedure}
% \begin{algorithmic}[1]
%   \Procedure{triSeg}{entier tab[], entier debut, entier fin}
%   \If{$debut<fin$}  // condition d'arrêt\pause
%     \State choisir élément pivot $p$ entre debut et fin\pause
%     \State placer pivot en $i$, $\le$ pivot avant, $\geqslant$ pivot après\pause
%     \State triSeg(tab, deb, i-1)
%     \State triSeg(tab, i+1, fin)
%   \EndIf
%   \EndProcedure
%%   \end{algorithmic}
%}
%}
%\only<5>{
  %{\small 
%\begin{procedure}[H]
  %\caption{triSeg(tableau\_entier tab, entier debut, entier fin)}
  %\If{$debut<fin$} {
    %\eIf{$fin - debut \leqslant 1$ \tcp{cas particulier : 2 éléments à trier}} {
      %\If{$tab[debut] > tab[fin]$} {
        %permuter tab[debut], tab[fin] \;
      %}
    %}
    %{
      %choisir élément pivot $p$ entre debut et fin \;
      %placer pivot en $i$, $\leqslant$ pivot avant, $\geqslant$ pivot après \;
      %\triSeg(tab, deb, i-1) \;
      %\triSeg(tab, i+1, fin) \;
    %}
  %}
%\end{procedure}
%% \begin{algorithmic}[1]
%%   \Procedure{triSegIns}{entier tab[], entier debut, entier fin}
%%     \If{$debut<fin$} // condition d'arrêt
%%       \If{\textcolor{blue}{$fin - debut \le seuil$}} // cas particulier 
%%         \State \textcolor{blue}{triIns(tab, debut, fin)}
%%       \Else
%%         \State choisir élément pivot $p$ entre debut et fin
%%         \State placer pivot en $i$, $\le$ pivot avant, $\geqslant$ pivot après
%%         \State triSeg(tab, deb, i-1)
%%         \State triSeg(tab, i+1, fin)
%%       \EndIf
%%     \EndIf
%%   \EndProcedure
%%   \end{algorithmic}
%}
%}
%\end{frame}


\subsection{Notion de récursivité terminale}


\begin{frame}
  \frametitle{Récursivité terminale}%}

  \begin{itemize}
  \item A chaque appel récursif : empilement de données\pause
  \item[$\Rightarrow$] limite au nombre d'appels possibles\pause
  \item Solution : récursivité terminale
  \end{itemize}

  \pause
  \begin{defi}[Récursivité terminale]
    Une fonction est dite récursive terminale s'il n'y a aucune opération sur
    ses appels récursifs.
  \end{defi}
  \pause
  \begin{exemple}[Fonction récursive non terminale]
    Factorielle :
    \begin{semiverbatim}
      return n*fact(n-1);
    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}
  \frametitle{Écriture de fonction récursive terminale}%}
  \begin{itemize}
  \item Idée générale : utiliser un accumulateur
  \item Paramètre qui contient le résultat intermédiaire
  \end{itemize}
  \begin{exemple}[Factorielle récursive terminale]
    \begin{semiverbatim}
      def fact(int n, int acc):

      \hspace{1cm}if n==0 :

      \hspace{2cm}return acc

      \hspace{1cm}else:

      \hspace{2cm}return fact(n-1, n*acc)

    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fonctionnement}%}
  Appel :
  \begin{semiverbatim}
    fact(4, 1)
  \end{semiverbatim}
  Si le langage sait optimiser la récursivité terminale, pas d'empilement
  d'appels $\Rightarrow$ Modification des valeurs dans la pile.
  \vspace{2mm}

  \begin{tabular}{ll}
    \begin{minipage}{0.5\linewidth}
    \begin{semiverbatim}
      fact(\only<1>{4}\only<2>{3}\only<3>{2}\only<4>{1}\only<5->{0}, \only<1>{1}\only<2>{4}\only<3>{12}\only<4>{24}\only<5->{24});
    \end{semiverbatim}
  \end{minipage}&
  \begin{minipage}{0.5\linewidth}
    \begin{tabular}{l|r|}
      \hline
      acc & \only<1>{1}\only<2>{4}\only<3>{12}\only<4>{24}\only<5->{24}\\
       \hline
      n & \only<1>{4}\only<2>{3}\only<3>{2}\only<4>{1}\only<5->{0}\\
      \hline
      %0x1E3C85\\

    \end{tabular}
  \end{minipage}
\end{tabular}

\uncover<6>{
  \begin{alertblock}{Remarque}
    Python n'optimise pas la récursivité terminale
  \end{alertblock}
}
\end{frame}

%\section{Eclipse}
%
%\begin{frame}
%\frametitle{Eclipse}
  %\begin{itemize}[<+->]
  %\item Disponible sur \url{http://www.eclipse.org}
  %\item Principe d'un IDE
  %\item Avantages / inconvénients
    %\begin{itemize}
    %\item Debugger
    %\item Analyse syntaxique à la volée
    %\item Lourdeur
    %\end{itemize}
  %\item Installation / utilisation : voir didacticiels sur \emph{moodle}
  %\end{itemize}
%\end{frame}
%\section{Un mot sur le projet "LCLC"}