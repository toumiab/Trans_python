
\section{Rappel paramètres formels/paramètres effectifs}

\begin{frame}
  \frametitle{Méthode fact}
  \begin{itemize}[<+-|alert@+>]
  \item Paramètres formels
  \item Paramètres effectifs
  \end{itemize}

  \begin{semiverbatim}
    public int \textcolor{blue}{fact}({\color<1>{red}int i}) \{

    \hspace{1cm}if(i == 0) \{

    \hspace{1cm}...

    \}

    public void cnp(int n, int p) \{

    \hspace{1cm}int num = \textcolor{blue}{fact}({\color<2>{red}n});

    \hspace{1cm}...

    \}
  \end{semiverbatim}
\end{frame}


\section{Récursivité}


\subsection{Définition}


\begin{frame}
  \frametitle{Définition}
\begin{defi}[Fonction récursive]
  Une fonction ou une méthode est dite récursive si elle se définit à partir
  d'elle même, c'est-à-dire si elle comporte un appel à elle même dans son
  corps.
\end{defi}

\pause
\begin{alertblock}{Attention}
  Éviter les boucles infinies (appel systématique à la méthode).
\end{alertblock}
\pause
\begin{exemple}[Méthode infinie]
  \begin{semiverbatim}
    public int sansFin(int n)  \{

    \hspace{1cm}return n+sansFin(n-1);

    \}
  \end{semiverbatim}
\end{exemple}
\end{frame}


\begin{frame}
  \frametitle{Exemple}

  Traduction immédiate des fonctions définies par récurrence.

  \begin{exemple}[Factorielle]
    $\left\{
      \begin{array}{l}
        \color<3>{red}0! = 1\\
        \color<4>{red}n! = n(n-1)!
      \end{array}
    \right.
    $\\
    
    \pause

    \begin{semiverbatim}
      public int \textcolor{blue}{fact}(int n) \{\pause

      \hspace{1cm}if (n==0)

      \hspace{2cm}return 1;\pause

      \hspace{1cm}else

      \hspace{2cm}return n*\textcolor{blue}{fact}(n-1);

      \}
    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}
  \frametitle{Condition d'arrêt}

  \begin{defi}[Condition d'arrêt]
    Condition pour laquelle il n'y a pas d'appel récursif.
  \end{defi}
  \pause
  \begin{alertblock}{Important}
    Toute méthode récursive doit comporter au moins une condition
    d'arrêt. Sinon : boucle infinie.
  \end{alertblock}
  \pause
  \begin{remarque}
    Une méthode peut comporter plusieurs conditions d'arrêt.
  \end{remarque}
\end{frame}


\begin{frame}
  \frametitle{Condition d'arrêt}
  \begin{exemple}[Plusieurs conditions d'arrêt]
    \begin{semiverbatim}
      public int fact(int n) \{

      \hspace{1cm}{\color<2>{red}if (n==0)}
      
      \hspace{2cm}return 1;

      \hspace{1cm}{\color<2>{red}else if (n==1)}

      \hspace{2cm}return 1;

      \hspace{1cm}else

      \hspace{2cm}return n*fact(n-1);

    \}
    \end{semiverbatim}
  \end{exemple}
\end{frame}


\subsection{Pile d'appel}

\begin{frame}
  \frametitle{Pile d'appel}
  \begin{itemize}[<+->]
  \item Zone de mémoire
  \item Contient :
    \begin{itemize}
    \item<3-|alert@8-9> paramètres
    \item<4-|alert@10> adresse de retour
    \item<5-|alert@11> variables locales
    \end{itemize}
  \item<6-> Fonctionnement lors de l'appel d'une méthode
  \end{itemize}

  \uncover<7->{
  \begin{tabular}{ll}
    \begin{minipage}{0.8\linewidth}
    \begin{semiverbatim}
      public void methode({\color<8>{red}int a}, {\color<9>{red}double b}) \{

      \hspace{1cm}{\color<11>{red}int i};

      \}

      methode({\color<8>{red}2}, {\color<9>{red}1.5});
    \end{semiverbatim}
  \end{minipage}&
  \begin{minipage}{0.15\linewidth}
  \begin{tabular}{|r|}
    \hline
    \uncover<11>{i}\\
    \hline
    \uncover<10->{0x1E3C85}\\
    \hline
    \uncover<9->{1.5}\\
    \hline
    \uncover<8->{2}\\
    \hline
  \end{tabular}
  \end{minipage}
\end{tabular}
}
\end{frame}


\begin{frame}
  \frametitle{Pile et récursivité}

  \begin{itemize}
  \item Pile d'appel : notion fondamentale pour la récursivité.
  \item Principe : tous les appels sont empilés, traités, puis dépilés.
  \end{itemize}
  ~\\

  \begin{tabular}{ll}
    \begin{minipage}{0.6\linewidth}
    \begin{semiverbatim}
      public int fact(int n) \{

      \hspace{1cm}if (n==0)

      \hspace{2cm}return 1;

      \hspace{1cm}else

      \hspace{2cm}return n*fact(n-1);

      \}
    \end{semiverbatim}
  \end{minipage}&
  \begin{minipage}{0.35\linewidth}
  \begin{tabular}{|ll|}
    \hline
    \uncover<5-6>{fact(0)}&\uncover<6>{=1}\\
    \hline
    \uncover<3-7>{fact(1)}&\uncover<4-7>{=\only<-6>{1*fact(0)}\only<7->{1}}\\
    \hline
    fact(2)&\uncover<2->{=\only<-7>{2*fact(1)}\only<8->{2}}\\
    \hline
  \end{tabular}
  \end{minipage}
\end{tabular}

\end{frame}



\subsection{Explosion combinatoire}

\begin{frame}
  \frametitle{Suite de Fibonacci}
  $\left\{
    \begin{array}{l}
      \color<2>{red}F_0 = 0\\
      \color<2>{red}F_1 = 1\\
      \color<3>{red}\forall n \geqslant 2, F_n = F_{n-1} + F_{n-2}
    \end{array}
  \right.
  $\\

  \only<2-3>{
    \begin{itemize}
    \item<2-> Deux conditions d'arrêt
    \item<3-> Une condition de récurrence
    \end{itemize}}
  
  \only<4->{
    \begin{semiverbatim}
      public int \textcolor{blue}{fibo}(int n) \{
      
      \hspace{1cm}if (n==0)
      
      \hspace{2cm}return 0;

      \hspace{1cm}else if (n==1)

      \hspace{2cm}return 1;

      \hspace{1cm}else

      \hspace{2cm}return \textcolor{blue}{fibo}(n-1) + \textcolor{blue}{fibo}(n-2);

      \}    
    \end{semiverbatim}
  }
\end{frame}

\begin{frame}
  \frametitle{Explosion de la pile d'appel}
  Évolution de la pile lors du calcul de F(3) :\\

  \begin{tabular}{|ll|}
    \hline
    \uncover<7-8>{\color<7-8>{purple}f(0)} & \uncover<8>{= 0}\\
    \hline
    \uncover<5-8,10-11>{\color<4-6>{purple}\color<10-11>{blue}f(1)} & \uncover<6-8,11>{= 1}\\
    \hline
    \uncover<3-11>{\color<3-9>{blue}f(2)} & \uncover<4-11>{= \only<-8>{{\color<4-6>{purple}f(1)}+{\color<7-9>{purple}f(0)}}\only<9->{1}}\\
    \hline
    f(3) & \uncover<2->{= \only<2-11>{{\color<2-9>{blue}f(2)}+{\color<10-11>{blue}f(1)}} \only<12->{2}}\\
    \hline
  \end{tabular}\\

  \begin{itemize}
  \item<13-> Traduction immédiate de la formule de récurrence
  \item[$\Rightarrow$]<14-> peu efficace dans ce cas
  \item<15-> Nombre d'appel à F en $\Theta(2^n)$
  \item<16-> Risque de \emph{java.lang.StackOverflowError}
  \end{itemize}
\end{frame}


\subsection{Conception d'algorithme récursif}

\begin{frame}
  \frametitle{Conception d'algorithme récursif}

  \begin{itemize}[<+->]
  \item Découper l'algorithme en étapes
  \item Déterminer les règles de passage d'une étape à l'autre
  \item[$\Rightarrow$] l'étape $n$ dépend de l'étape $n-1$ (éventuellement $n-2$)
  \item Déterminer les conditions d'arrêt
  \end{itemize}

  \pause
  \begin{remarque}
    Tout algorithme récursif peut s'écrire de manière itérative, et
    réciproquement. 
  \end{remarque}
\end{frame}


\subsection{Exemples}

\begin{frame}
  \frametitle{Recherche par dichotomie}

  \begin{itemize}[<+->]
  \item Recherche d'un élément dans un tableau trié
  \item Principe :
    \begin{itemize}
    \item comparer l'élément recherché avec le milieu du tableau
    \item si $>$ : recherche dans le tableau $\Leftrightarrow$ recherche dans
      la partie droite
    \item si $<$ : recherche dans le tableau $\Leftrightarrow$ recherche dans
      la partie gauche
    \item si $=$ : élément trouvé (condition d'arrêt)
    \item autre condition d'arrêt : taille du tableau  $\leqslant 1$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recherche par dichotomie : code Java}
  \begin{semiverbatim}
    public boolean rech(int tab[], int val, int deb, int fin)
\{

  \hspace{1cm}int n = (deb + fin)/2;\pause

  \hspace{1cm}if (tab[n] == val)

    \hspace{2cm}return true;\pause

  \hspace{1cm}else if(deb >= fin)

    \hspace{2cm}return false;\pause

  \hspace{1cm}else if (tab[n] > val)

    \hspace{2cm}return rech(tab, val, deb, n-1);

  \hspace{1cm}else 

    \hspace{2cm}return rech(tab, val, n+1, fin);

\}
  \end{semiverbatim}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Tours de Hanoï}
  Principe :
  \begin{itemize}
  \item Disques empilés : tour
  \item Ne jamais empiler un disque sur un disque plus petit
  \item Déplacer un seul disque à la fois
  \end{itemize}
  \begin{center}
\tikzset{
    disc/.style={shade, shading=radial, rounded rectangle,minimum height=.3cm,
        inner color=#1!20, outer color=#1!60!gray},
    disc 1/.style={disc=yellow, minimum width=12mm},
    disc 2/.style={disc=orange, minimum width=16mm},
    disc 3/.style={disc=red, minimum width=20mm},
    disc 4/.style={disc=green, minimum width=24mm},
    disc 5/.style={disc=blue, minimum width=28mm},
    disc 6/.style={disc=purple, minimum width=32mm},
    disc 7/.style={disc=teal, minimum width=36mm},
}

% Define some colors, I don't like plain green and brown.
\definecolor{darkgreen}{rgb}{0.2,0.55,0}
\definecolor{darkbrown}{rgb}{0.375,0.25,0.125}

\begin{tikzpicture}
  \foreach \n/\x in {1/0cm,2/3.5cm,3/7cm} {
    \begin{scope}[xshift=\x]
      \fill[darkbrown] (-1.5cm, 0) rectangle (1.5cm,0.2cm)
      (-1mm,2mm) rectangle (1mm,3.2cm);
      \ifnum \n=1
      \foreach \y in {1,...,7} {
        \node[disc \y,yshift={32mm-\y*4mm}] {\scriptsize\y};
      }
      \fi
      % \expandafter\discs\csname pole \n\endcsname
    \end{scope}
  }
\end{tikzpicture}
   % \includegraphics[width=0.7\linewidth]{tours_hanoi}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Tours de Hanoï : résolution}
  \begin{itemize}
  \item Résolution par une méthode récursive
  \item Étapes de l'algorithme : hauteur de la tour
  \item Hauteur 0 : évident
  \item Récurrence :
    \begin{itemize}
    \item on suppose savoir déplacer une tour de hauteur $h-1$
    \item on veut déplacer une tour de hauteur $h$ de A vers B
    \item déplacer les $h-1$ premiers éléments de A vers C
    \item déplacer l'élément restant de A vers B
    \item déplacer les $h-1$ premiers éléments de C vers B
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tours de Hanoï : algorithme}

%\begin{algorithme}{Algorithme des tours de Hanoï}{alg:hanoi}
%  \proc \algverb{hanoi} (entier n, entier source, entier dest, entier tmp)\\
%  \vars \=\\
%  \> n : hauteur de la tour\\
%  \> source, dest, tmp\\
%  \debut \=\\
%  \> \si \= $n>0$ \alors\\
%  \> \> hanoi(n-1, source, tmp, dest)\\
%  \> \> déplacer(source, dest)\\
%  \> \> hanoi(n-1, tmp, dest, source)\\
%  \> \fin\\
%  \fin
%\end{algorithme}
  {\small 
\begin{procedure}[H]
  \caption{hanoi(entier n, entier source, entier dest, entier tmp)}
  \tcc{n~: hauteur de la tour\\ source, dest, tmp~: 
    position d'origine, finale et intermédiaire de la tour à déplacer}
  \If{$n>0$} { 
    \hanoi(n-1, source, tmp, dest) \;
    déplacer(source, dest) \;
    \hanoi(n-1, tmp, dest, source) \;
  }
\end{procedure}
% \begin{algorithmic}[1]
%     \Procedure{Hanoï}{entier n, entier source, entier dest, entier tmp}
%     \Var
%     \State n : hauteur de la tour
%     \State source, dest, tmp
%     \EndVar
%     \If{$n>0$}
%     \State hanoi(n-1, source, tmp, dest)
%     \State déplacer(source, dest)
%     \State hanoi(n-1, tmp, dest, source)
%     \EndIf
%     \EndProcedure
%   \end{algorithmic}
}
\end{frame}

\begin{frame}
  \frametitle{Étude de l'algorithme tours de Hanoï}
  $C(n)$ : nombre d'opération pour déplacer une tour de hauteur $n$\\
  \pause ~\\
    $\left\{
      \begin{array}{l}
        C(n+1) = 2C(n) + 1\\
        C(0) = 0
      \end{array}
    \right.
    $\\
    \pause ~\\
    Résolution : $C(n) = 2^n - 1$
    
    \vspace{2mm}\pause 
    Légende des tours de Hanoï : dans un temple Bouddhiste, des moines ont reçu
    pour mission de déplacer une tour de Hanoï de 64 disques. Lorsqu'ils
    l'auront déplacée, le monde tombera en poussière.\\
    \pause
    $2^{64}-1 = 18\, 446\, 744\, 073\, 709\, 551\, 615$

    Un déplacement par seconde $\leadsto$ 580 milliards d'années
\end{frame}


\begin{frame}
  \frametitle{Monnaie}
  Problème : 
  \begin{itemize}[<+->]
  \item Combien de manières de rendre la monnaie sur une somme $s$
    avec 1, 2 ou 5 \euro{} ?
  \item Résolution : méthodes récursives.
  \end{itemize}

  \pause Algorithme :
  \begin{itemize}[<+->]
  \item Rendre la monnaie sur $s$ avec des pièces de 1 \euro{} : 1 seule possibilité
  \item Rendre la monnaie sur $s$ avec 1 ou 2 \euro{} :
    \begin{itemize}
    \item Donner une pièce de 2\euro{} et rendre la monnaie sur $s-2$ avec 1 ou
      2 \euro{}
    \item Ou rendre la monnaie uniquement avec 1\euro{}
    \end{itemize}
  \item Rendre la monnaie sur $s$ avec 1, 2 ou 5 \euro{} : même principe
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Algorithme}
%  \begin{algorithme}{Rendre la monnaie}{alg:monnaie}
%    \proc \algverb{monnaie1} (somme s)\\
%    \debut \=\\
%    \> retourner 1\\
%    \fin\\ \pause
%    \proc \algverb{monnaie1-2} (somme s)\\
%    \debut \=\\
%    \> retourner monnaie1-2(s-2) + monnaie1(s)\\
%    \fin\\ \pause
%    \proc \algverb{monnaie1-2-5} (somme s)\\
%    \debut \=\\
%    \> retourner monnaie1-2-5(s-5) + monnaie1-2(s) + monnaie1(s)\\
%    \fin
%  \end{algorithme}
  {\small 
\begin{procedure}[H]
  \caption{monnaie1(somme s)}
  retourner 1\;
\end{procedure}
\begin{procedure}[H]
  \caption{monnaie1-2(somme s)}
 retourner \emph{monnaie1-2}(s-2) + \emph{monnaie1}(s)\;
\end{procedure}
\begin{procedure}[H]
  \caption{monnaie1-2-5(somme s)}
 retourner \emph{monnaie1-2-5}(s-5) + \emph{monnaie1-2}(s) + \emph{monnaie1}(s)\;
\end{procedure}

% \begin{algorithmic}[1]
%     \Procedure{monnaie1}{somme s}
%       \State retourner 1
%     \EndProcedure
%     \Procedure{monnaie1-2}{somme s}
%       \State retourner monnaie1-2(s-2) + monnaie1(s)
%     \EndProcedure
%     \Procedure{monnaie1-2-5}{somme s}
%       \State retourner monnaie1-2-5(s-5) + monnaie1-2(s) + monnaie1(s)
%     \EndProcedure
%   \end{algorithmic}
}
\end{frame}

\begin{frame}
  \frametitle{Algorithme : condition d'arrêt}
  \begin{itemize}
  \item Conditions d'arrêt de l'algorithme ?
  \item \emph{monnaie1} non récursive : pas de condition d'arrêt
  \item Pour \emph{monnaie1-2} : s'arrêter si $s<2$
  \item Pour \emph{monnaie1-2-5} : s'arrêter si $s<5$
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Quicksort}
\only<1-4>{
  {\small 
\begin{procedure}[H]
  \caption{triSeg(tableau\_entier tab, entier debut, entier fin)}
  \If{$debut<fin$} {\pause
      choisir élément pivot $p$ entre debut et fin \;\pause
      placer pivot en $i$, $\leqslant$ pivot avant, $\geqslant$ pivot après \;\pause
      \triSeg(tab, deb, i-1) \;
      \triSeg(tab, i+1, fin) \;
  }
\end{procedure}
% \begin{algorithmic}[1]
%   \Procedure{triSeg}{entier tab[], entier debut, entier fin}
%   \If{$debut<fin$}  // condition d'arrêt\pause
%     \State choisir élément pivot $p$ entre debut et fin\pause
%     \State placer pivot en $i$, $\le$ pivot avant, $\geqslant$ pivot après\pause
%     \State triSeg(tab, deb, i-1)
%     \State triSeg(tab, i+1, fin)
%   \EndIf
%   \EndProcedure
%   \end{algorithmic}
}
}
\only<5>{
  {\small 
\begin{procedure}[H]
  \caption{triSeg(tableau\_entier tab, entier debut, entier fin)}
  \If{$debut<fin$} {
    \eIf{$fin - debut \leqslant 1$ \tcp{cas particulier : 2 éléments à trier}} {
      \If{$tab[debut] > tab[fin]$} {
        inverser(tab, debut, fin) \;
      }
    }
    {
      choisir élément pivot $p$ entre debut et fin \;
      placer pivot en $i$, $\leqslant$ pivot avant, $\geqslant$ pivot après \;
      \triSeg(tab, deb, i-1) \;
      \triSeg(tab, i+1, fin) \;
    }
  }
\end{procedure}
% \begin{algorithmic}[1]
%   \Procedure{triSegIns}{entier tab[], entier debut, entier fin}
%     \If{$debut<fin$} // condition d'arrêt
%       \If{\textcolor{blue}{$fin - debut \le seuil$}} // cas particulier 
%         \State \textcolor{blue}{triIns(tab, debut, fin)}
%       \Else
%         \State choisir élément pivot $p$ entre debut et fin
%         \State placer pivot en $i$, $\le$ pivot avant, $\geqslant$ pivot après
%         \State triSeg(tab, deb, i-1)
%         \State triSeg(tab, i+1, fin)
%       \EndIf
%     \EndIf
%   \EndProcedure
%   \end{algorithmic}
}
}
\end{frame}


\subsection{Notion de récursivité terminale}


\begin{frame}
  \frametitle{Récursivité terminale}

  \begin{itemize}
  \item A chaque appel récursif : empilement de données\pause
  \item[$\Rightarrow$] limite au nombre d'appels possibles\pause
  \item Solution : récursivité terminale
  \end{itemize}

  \pause
  \begin{defi}[Récursivité terminale, tail recursion]
    Une méthode est dite récursive terminale s'il n'y a aucune opération sur
    ses appels récursifs.
  \end{defi}
  \pause
  \begin{exemple}[Méthode récursive non terminale]
    Factorielle :
    \begin{semiverbatim}
      return n*fact(n-1);
    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}
  \frametitle{Écriture de méthode récursive terminale}
  \begin{itemize}
  \item Idée générale : utiliser un accumulateur
  \item Paramètre qui contient le résultat intermédiaire
  \end{itemize}
  \begin{exemple}[Factorielle récursive terminale]
    \begin{semiverbatim}
      public int fact(int n, int acc) \{

      \hspace{1cm}if (n==0)

      \hspace{2cm}return acc;

      \hspace{1cm}else

      \hspace{2cm}return fact(n-1, n*acc);

      \}
    \end{semiverbatim}
  \end{exemple}
\end{frame}

\begin{frame}
  \frametitle{Fonctionnement :}
  Appel :
  \begin{semiverbatim}
    fact(5, 1);
  \end{semiverbatim}
  Si le langage sait optimiser la récursivité terminale, pas d'empilement
  d'appels. Modification des valeurs dans la pile.
  \vspace{2mm}

  \begin{tabular}{ll}
    \begin{minipage}{0.5\linewidth}
    \begin{semiverbatim}
      fact(\only<1>{4}\only<2>{3}\only<3>{2}\only<4>{1}\only<5->{0}, \only<1>{1}\only<2>{4}\only<3>{12}\only<4>{24}\only<5->{24});
    \end{semiverbatim}
  \end{minipage}&
  \begin{minipage}{0.5\linewidth}
    \begin{tabular}{|r|}
      \hline
      \only<1>{1}\only<2>{4}\only<3>{12}\only<4>{24}\only<5->{24}\\
      \hline
      \only<1>{4}\only<2>{3}\only<3>{2}\only<4>{1}\only<5->{0}\\
      \hline
      0x1E3C85\\
      \hline
    \end{tabular}
  \end{minipage}
\end{tabular}

\uncover<6>{
  \begin{alertblock}{Remarque}
    Java n'optimise pas la récursivité terminale
  \end{alertblock}
}
\end{frame}

\section{Eclipse}

\begin{frame}
\frametitle{Eclipse}
  \begin{itemize}[<+->]
  \item Disponible sur \url{http://www.eclipse.org}
  \item Principe d'un IDE
  \item Avantages / inconvénients
    \begin{itemize}
    \item Debugger
    \item Analyse syntaxique à la volée
    \item Lourdeur
    \end{itemize}
  \item Installation / utilisation : voir didacticiels sur \emph{moodle}
  \end{itemize}
\end{frame}
